(define (print x) (pr x) (pr #\n) x)
(define (trace x) (pr "> ") (print x))
(define (tr x) (pr "> ") (print x))

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (negative x) (- 0 x))
(define (not x) (if x false true))
(define (not-equal? x y) (not (equal? x y)))

(define (char-in str c)
  (define (loop i)
          (if (< i (size str))
              (or (equal? (char-at str i) c)
                  (loop (+ i 1)))
              false))
  (loop 0))

(define (count xs)
  (if xs
      (+ 1 (count (cdr xs)))
      0))

(define (reverse xs)
  (define (loop xs out)
          (if xs
             (loop (cdr xs) (cons (car xs) out))
             out))
  (loop xs ()))

(define (foldl combine init xs)
  (define (loop xs out)
          (if xs
              (loop (cdr xs) (combine out (car xs)))
              out))
  (loop xs init))

(define (foldl* combine xs)
  (foldl combine (car xs) (cdr xs)))

(define (foldr combine init xs)
  (define (loop xs out)
          (if xs
              (loop (cdr xs) (combine (car xs) out))
              out))
  (loop (reverse xs) init))

(define (append before after)
  (foldr cons after before))

(define (map f xs)
  (define (loop xs out)
          (if xs
              (loop (cdr xs) (cons (f (car xs)) out))
              (reverse out)))
  (loop xs []))

(define (apply f xs)
  (define (loop xs)
          (if xs
              (begin (f (car xs))
                     (loop (cdr xs)))
              ()))
  (loop xs))

(define (all? accept? list)
  (if list
      (and (accept? (car list))
           (any? accept? (cdr list)))
      true))

(define (any? accept? list)
  (if list
      (or (accept? (car list))
          (any? accept? (cdr list)))
      false))

(define (none? accept? list) (not (any? accept? list)))

(define (member? list item)
  (any? (fn (i) (equal? i item)) list))

(define (assoc key env)
  (if env
      (if (equal? key (caar env))
          (car env)
          (assoc key (cdr env)))
      nil))

(define (digit? c) (and (<= #0 c) (<= c #9)))
(define (lowercase? c) (and (<= #a c) (<= c #z)))
(define (uppercase? c) (and (<= #A c) (<= c #Z)))
(define (letter? c) (or (lowercase? c) (uppercase? c)))
(define (letter-or-digit? c) (or (lowercase? c) (uppercase? c) (digit? c)))
(define (space? c) (or (equal? #  c) (equal? #\t c) (equal? #\n c)))

(define (int->str x)
  (define digits "0123456789")
  (define (loop x out)
          (if (equal? x 0)
              (join out)
              (loop (/ x 10) (cons (char-at digits (rem x 10)) out))))
  (cond ((equal? x 0) "0")
        ((< x 0) (join ["-" (loop (negative x) [])]))
        (true    (loop x []))))

(define (str->int str)
  (define (loop i out)
          (if (< i (size str))
              (begin (define c (char-at str i))
                     (loop (+ 1 i) (+ (* 10 out) (- (ord c) 48))))
              out))
  (if (equal? #- (char-at str 0))
      (negative (loop 1 0))
      (loop 0 0)))

(define (scanner name source)
  (define index 0)
  (define line 1)
  (define col 1)
  (define (more?) (< index (size source)))
  (define (loc) (join [name ":" (int->str line) ":" (int->str col)]))
  (define (error msg) (print (join ["boot-ml: error " (loc) ": " msg #\n]))
                      (exit 1))
  (define (peek) (if (more?)
                     (char-at source index)
                     #\0))
  (define (advance) (define c (peek))
                    (if (equal? c #\n)
                        (begin (set line (+ 1 line))
                               (set col 1))
                        (set col (+ col 1)))
                    (set index (+ 1 index))
                    c)
  (define (get base type accept?)  (while accept?)
                              (cons type (substr source base index)))
  (define (while accept?) (if (and (more?) (accept? (peek)))
                              (begin (advance)
                                     (while accept?))))
  (define reserved
    '("!" "--" "->" "::" "=" "@" "and" "case"
        "datatype" "else" "fn" "if" "in" "infixl" "infixr"
        "let" "rec" "then" "where" "|"))
  (define (pun? c) (char-in "()[],;`\\" c))
  (define (symbol? c) (char-in "!$%&*+-/:<=>@^|~" c))
  (define (id-char? c) (or (letter-or-digit? c) (char-in "_!?'" c)))
  (define (with-escape quote c) (cond ((equal? c #\\)   (advance) true)
                                      ((equal? c quote) (advance) false)
                                      (true             true)))
  (define (string? c) (with-escape #\" c))
  (define (character? c) (with-escape #' c))
  (define (no-more c) false)
  (define (next)  (define loc (loc))
                  (define base index)
                  (define c (advance))
                  (define type&text
                    (cond ((pun? c)       (get base "pun" no-more))
                          ((digit? c)     (get base "int" digit?))
                          ((equal? c #')  (get (+ 1 base) "char" character?))
                          ((equal? c #\") (get (+ 1 base) "string" string?))
                          ((id-char? c)   (get base "id" id-char?))
                          ((symbol? c)    (get base "id" symbol?))
                          (true           (error "bad token"))))
                  (tr (cons loc (post type&text))))
  (define (post type&text)
    (define type (car type&text))
    (define text (cdr type&text))
    (define first-char (char-at text 0))
    (define last-char (char-at text (- (size text) 1)))
    (cond ((equal? type "id") (cond ((member? reserved text) (cons type text))
                                    ((uppercase? first-char) (cons "con" text))
                                    ((equal? #: first-char)  (cons "con" text))
                                    (true                    (cons "id" text))))
          ((equal? type "string") (if (not-equal? last-char #\")
                                      (error "unclosed string"))
                                  (cons "string" (substr text 0 (- (size text) 1))))
          ((equal? type "char")   (if (not-equal? last-char #')
                                      (error "unclosed character"))
                                  (cons "char" text))
          ((equal? type "pun")    (cons text text))
          (true                   type&text)))
  (define (space) (cond ((space? (peek))    (while space?) (space))
                        ((equal? (peek) ##) (while end-comment?) (space))
                        (true               (more?))))
  (define (loop out)
    (if (space)
        (loop (cons (next) out))
        (reverse (cons (eof) out))))
  (loop))

(define filename "test.ml")
(define source (read-file filename))
(define tokens (scanner filename source))
(apply print tokens)
